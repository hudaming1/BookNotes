####多线程一定就快吗
> 不一定，相比单线程而言，创建线程和上下文切换会带来额外的开销，且如果用到了Lock时，资源的竞争也会带来损耗。使用多线程的目的是为了更大限度征用CPU，如果CPU已经处于满负荷状态，使用多线程也无法提升效率。

####如何查看上下文切换
> vmstat命令

####如何减少上下文切换
> 1. 无锁编程：例如对ID进行Hash取摸进行数据迁移，不同线程处理不同的数据段。
> 2. 减少线程数
> 3. CAS算法
> 4. 协程：用单线程任务调度代替多线程

####什么是死锁，如何发生的
> 多个线程在执行过程中，相互等待对方释放最终造成阻塞的一种现象，如果没有外力干预，则程序一直无法运行。

####如果避免死锁，或如何排查死锁
> 1. 设置加锁顺序
> 2. 设置加锁等待时限：在竞争锁时设置超时时间，一定时间内无法获得到锁，则退出等待。
> 3. 死锁检测
> 通过jstack线程可以直接查看当前处于死锁的线程。

####关于volatile
> 【作用】volatile主要作用是提供线程的可见性，以及禁止对指令重排序。  
> 【原理】volatile变量不会被缓存在寄存器中，每次读取都是从主存中获取变量最新值。  
> 【实现】当volatile修饰的变量发生更改时：会将缓存行中的变量回写到主存中，且通知其他引用该变量的线程缓存数据失效。

> 【使用场景】
>> 1. 状态标志（例如Server状态）
>> 2. 禁止指令重排序（线程安全的单例模式 ）

> 使用原则：写入变量不依赖此变量的值，或者只有一个线程修改此变量

####关于synchronized
> 【原理】JVM会针对被synchronized修饰的代码，隐形的插入monitorenter和monitorexit指令，当jvm执行到monitorenter指令时，当前线程试图获取monitor对象(依赖底层操作系统的Mutex Lock)的所有权，如果未加锁或者已经被当前线程所持有，就把锁的计数器+1；当执行monitorexit指令时，锁计数器-1；当锁计数器为0时，该锁就被释放了。如果获取monitor对象失败，该线程则会进入阻塞状态，直到其他线程释放锁。  
> 【关于对象头】synchronized用的锁存在Java对象头中，主要存了锁的级别（轻量级锁、重量级锁、偏向锁），以及锁记录指针。

> synchronized可重入吗：是可重入的

####关于CAS
> Compare And Swap从操作系统层面就是一个原子指令，对比旧值，匹配成功则更新为新值。

####锁优化
> 【偏向锁】当一个线程第一次获得锁后再次申请获取就可以直接拿到锁，相当于无锁，这种情况下效率最高。  
> 【轻量级锁】在没有多线程竞争，但有多个线程交替执行情况下，避免调用系统函数mutex（特指linux系统）产生的性能消耗。  
> 【重量级锁】发生了多线程竞争，就会调用mutex函数使得未获取到锁的线程进入睡眠状态。  
> 【锁消除】代码经过逃逸分析后，判断没有数据会逃逸出线程，就不会给这段这段代码加锁。  
> 【锁粗化】如果虚拟机检测到有一系列零碎的操作都对同一对象加锁，就会将整个同步操作扩大到这些操作的外部，这样就只需要加锁一次即可，减少加锁释放锁带来的性能损耗。  
> 参考：https://www.cnblogs.com/yewy/p/13584915.html


####Happen-Before
> 【Happen-before是什么】happen-before是JMM中定义的一套规则。  
> 【Happen-before解决了什么问题】JVM通过定义Happen-before，对OS建立起了一套禁止指令重排序的规则，且这个规则对开发人员可见并可控。  
> 【Happen-before规则】1.synchronized释放先于加锁；2.a before b，b before c，那么a也一定before c；3.volatile的写before读

####Daemon线程怎么使用
> Daemon线程一般作为后台守护线程使用，当整个JVM所有非Daemon线程退出后，JVM也会随之结束。通过Thread.setDaemon(true)可以将线程设置为Daemon线程。一般用于支持性的工作，典型的GC线程就是Daemon模式，当一般线程退出后，GC线程也就认为无事可做，也可以随之退出了。

####ConcurrentHashMap实现原理
>【数据结构】与HashMap类似是一个链表数组，在ConcurrntHashMap中是Segment + HashEntry的方式进行实现。   
>【锁机制】  
>【jdk1.8为什么要用红黑树代替】

####Fork/Join框架
> 【What's Fork/Join】Fork/Join是JDK7中用于并行执行任务的框架，可以将一个大任务拆分成多个小任务(Fork环节)，然后再将小任务的执行结果合并为最终结果(Join环节)。   
> 【使用场景】可以将一个大任务拆分为多个互不相干的小任务，每个小任务交给单独一个线程执行，子任务并行期间与其他线程无任何交互，避免了锁竞争的开销，例如归并排序。

####CyclicBarrier使用场景
>【使用原理】为多个线程建立起一个屏障，当每个线程执行到达屏障时都会阻塞，只有最后一个线程也到达屏障时大门才会打开，所有线程都可以通过屏障继续执行下面程序。  
>【使用场景】大体上可以替换CountDownLatch的所有场景，且支持更复杂的业务，例如可重复执行，到达屏障后执行预处理等。缺点是个人感觉语义不如CountDownLatch明确，CountDownLatch的用法一般是主线程await，子任务会进行countdown，逻辑更清晰；而CyclicBarrier不做区分，全部用await来表示，个人感觉代码的可读性不友好（举一个连接池初始化的例子，对比CountDownLatch和CyclicBarrier代码语义上的差异）。

####Exchanger使用场景
> 线程间交换数据协同工作类。可以在2个线程之间向对方传入自己的数据，可用于类似对账这种业务场景。

####FutureTask
>【使用概述】提交一个异步任务，并在当前线程中阻塞等待返回结果。
>【实现原理】基于AQS实现，当调用get时，会进入自旋，然后通过LockSupport挂起当前线程，等待唤醒；当run执行完时会改变AQS的state，并唤醒挂起线程；调用get的线程被唤醒后会继续自旋，检查state，发现时Normal状态，则退出循环返回结果。

####实现生产者消费者代码
> 




