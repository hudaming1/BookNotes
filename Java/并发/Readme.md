####多线程一定就快吗
> 不一定，相比单线程而言，创建线程和上下文切换会带来额外的开销，且如果用到了Lock时，资源的竞争也会带来损耗。使用多线程的目的是为了更大限度征用CPU，如果CPU已经处于满负荷状态，使用多线程也无法提升效率。

####如何查看上下文切换
> vmstat命令

####如何减少上下文切换
> 1. 无锁编程：例如对ID进行Hash取摸进行数据迁移，不同线程处理不同的数据段。
> 2. 减少线程数
> 3. CAS算法
> 4. 协程：用单线程任务调度代替多线程

####什么是死锁，如何发生的
> 多个线程在执行过程中，相互等待对方释放最终造成阻塞的一种现象，如果没有外力干预，则程序一直无法运行。

####如果避免死锁，或如何排查死锁
> 1. 设置加锁顺序
> 2. 设置加锁等待时限：在竞争锁时设置超时时间，一定时间内无法获得到锁，则退出等待。
> 3. 死锁检测
> 通过jstack线程可以直接查看当前处于死锁的线程。

####关于volatile
> 【作用】volatile主要作用是提供线程的可见性，以及禁止对指令重排序。  
> 【原理】volatile变量不会被缓存在寄存器中，每次读取都是从主存中获取变量最新值。  
> 【实现】当volatile修饰的变量发生更改时：会将缓存行中的变量回写到主存中，且通知其他引用该变量的线程缓存数据失效。

> 【使用场景】
>> 1. 状态标志（例如Server状态）
>> 2. 禁止指令重排序（线程安全的单例模式 ）

> 使用原则：写入变量不依赖此变量的值，或者只有一个线程修改此变量

####关于synchronized
> 【原理】JVM会针对被synchronized修饰的代码，隐形的插入monitorenter和monitorexit指令，当jvm执行到monitorenter指令时，当前线程试图获取monitor对象(依赖底层操作系统的Mutex Lock)的所有权，如果未加锁或者已经被当前线程所持有，就把锁的计数器+1；当执行monitorexit指令时，锁计数器-1；当锁计数器为0时，该锁就被释放了。如果获取monitor对象失败，该线程则会进入阻塞状态，直到其他线程释放锁。  
> 【关于对象头】synchronized用的锁存在Java对象头中，主要存了锁的级别（轻量级锁、重量级锁、偏向锁），以及锁记录指针。

> synchronized可重入吗：是可重入的

####关于CAS
> Compare And Swap从操作系统层面就是一个原子指令，对比旧值，匹配成功则更新为新值。

####锁优化
> 【偏向锁】当一个线程第一次获得锁后再次申请获取就可以直接拿到锁，相当于无锁，这种情况下效率最高。  
> 【轻量级锁】在没有多线程竞争，但有多个线程交替执行情况下，避免调用系统函数mutex（特指linux系统）产生的性能消耗。  
> 【重量级锁】发生了多线程竞争，就会调用mutex函数使得未获取到锁的线程进入睡眠状态。  
> 【锁消除】代码经过逃逸分析后，判断没有数据会逃逸出线程，就不会给这段这段代码加锁。  
> 【锁粗化】如果虚拟机检测到有一系列零碎的操作都对同一对象加锁，就会将整个同步操作扩大到这些操作的外部，这样就只需要加锁一次即可，减少加锁释放锁带来的性能损耗。  
> 参考：https://www.cnblogs.com/yewy/p/13584915.html