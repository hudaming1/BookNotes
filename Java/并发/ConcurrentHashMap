####数据结构
数组＋链表＋红黑树

####并发原理
cas乐观锁+synchronized锁

####加锁对象
数组每个位置的头节点

####inittab时为什么要用thread.yield，能起到多大的作用？
> 

####初始化散列表时，如何保证线程安全
> 在初始化table时，通过自旋cas保证只能有一个线程初始化table，其余线程再cas失败后会通过thread.yield让出cpu时间片，然后退出初始化，直接进入put node环节。

####put node时如何保证线程安全
> 1.在散列表中对应的位置如果为null，则通过CAS创建一个链表头。
> 2.如果散列表中对应已经存在对象(可能是链表的头、也可能是RB树的根)，则进行synchonrized加锁，保证在这个段中同一时刻只能有一个线程给这个(链表/RB树)添加节点。

####扩容时如何保证线程安全，以及扩容时访问old map时如何保证线程安全
> 

####JDK8中，HashMap的节点用TreeNode，而ConcurrentHashMap的红黑树节点为什么用TreeBin
> 避免所在分段锁发生改变，因为红黑树在插入时为了保持平衡，根节点会发生变化，从而导致ConcurrentHashMap无法对同一个分段多次加上同一把锁。TreeBin作为整个红黑树对象，root节点发生变化只是TreeBin内部状态变化而已，对加锁无影响。

####ConcurrentHashMap如何统计size的
> 利用热点分散，先CAS竞争修改BaseCount字段，失败后再分散到修改CountCell数组。最终统计时利用BaseCount+sum(CountCell)即可
> 如果竞争修改CountCell失败，会重新计算线程随机数，尝试对其他CountCell进行修改，如果竞争再次失败，则会对CountCell进行扩容，增大热点范围。
> CountCell扩容终止条件时，当内部Cell数量超过CPU数量时，即停止扩容。

####get时没有没有锁？区分几种情概况，链表、红黑树，正在扩容阶段。

####是实现是为什么用了好多对象副本的方式，有什么好处吗？



#####负载因子可以修改吗？
不可以修改，默认是0.75，final修饰，通过概率算法泊松分布计算得出。

####Node对象的hash字段值代表什么含义
> -1代表：正在迁移数据，代表ForwardingNode节点
> -2代表：红黑树结构
> 正值代表：

####sizeCtl代表什么？
> 大于0：下次触发扩容的阈值
> -1代表：table正在初始化，执行initTab
> 小于-1：处于正在扩容状态，高16位标识扩容标识戳，低16位参与扩容的线程数+1

####扩容标识戳如何保证每个线程计算出的值是一致的，？
> 同一条件下，任何线程计算出来的戳是一致的，这个戳是和库容前表的大小相关。

####为什么扩容标识戳不一致会无法并发扩容
> 能标记处从小表到大表的扩容？

####如何保证写数据安全
> 

####hash寻址算法
> 用key的hashcode进行扰动运算，让hashcode高16位与低16位进行一个异或运算。将符号位强制设置为0，让hashcode成一个正整数。

####如何统计Map中的数据量，为什么不用AtomicLong统计呢？

####触发扩容的线程，在扩容前执行哪些预处理操作
> 1.修改sizeCtl，标记当前Map正在扩容
> 2.创建一个新table

####迁移完的桶怎么标记？
> 迁移完的桶用ForwardingNode标记，代表已经迁移完毕了。查询时遇到ForwardingNode节点，可以直接将查询定位到新的引用。

####扩容的时候，写数据如何处理
> 写

####扩容期间，读数据有影响吗？
没影响，调用find方法，扩容的时候不会破坏原来的table，遍历任然可以继续，不需要加锁

####扩容期间，扩容线程如何维护sizeCtl的低16位，即参与扩容的线程数？
通过CAS更新+1，退出前通过CAS更新减一

####最后一个退出扩容任务的线程做哪些收尾工作
> 当sizeCtl低16位减一后等于1时，判定自己是last线程，recheck老表，期望全部slot都是forwrd节点，如果不是则再迁移。
> 计算出下一次扩容的阈值，保存到sizeCtl
> 最后一个退出的线程，则将就table的地址更新指向新table的地址，这样后面的操作就是新table的操作了。

####TreeBin的state状态标识什么含义

####红黑树节点面对读写并发时怎么处理
读数据时，不能进行写操作：由于写数据会对红黑树早晨失衡，这时读线程无法在一个正在发生变化的树上进行查询。
TreeBin有一个state字段，每个线程读数据之前，都有会CAS将state+4，读完后再-4，写线程在写数据前会检查state字段是不是0

####如果TreeBin处于读时，有写线程进来怎么处理
无法写入，写线程会将Thread引用放到TreeBin对象中，将statebit位第二位标记为有线程等待写，然后使用LockSupport.park()挂起线程，
然后等待读完毕后检查state第二个位标志位，发现有等待写线程，再唤醒即可。

####如果TreeBin处于写操作(state=1)，有读线程来了怎么办？
TreeBin内部维护两个存储结构，一个是Tree本身，还有是链表结构，此时因为Tree可能存在调整，因此会将读请求转发到链表上去

####整个CMap分为几块学习：
1.put
  (√)链表put   
  tree.put
  (-)扩容
  计数
  树化
  
2.get
  链表get时是否可以put
  tree put时是否可以get



https://www.cnblogs.com/ylspace/p/12726672.html